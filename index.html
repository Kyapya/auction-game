<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>オークション (Restored & Online)</title>
<script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>

<style>
/* ■■■ CSS: デザイン設定 ■■■ */
:root { --bg: #2d5e2e; --primary: #f39c12; --danger: #e74c3c; --blue: #3498db; }
body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
    background-color: var(--bg); color: white; margin: 0; padding: 0;
    height: 100dvh; display: flex; flex-direction: column; overflow: hidden;
    user-select: none; -webkit-user-select: none; touch-action: manipulation;
}

/* 画面切り替え用 */
.screen { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 100; display: flex; flex-direction: column; justify-content: center; align-items: center; }
.hidden { display: none !important; }

/* タイトル・ロビー */
h1 { color: var(--primary); font-size: 2.5rem; margin-bottom: 30px; text-shadow: 2px 2px 0 #000; }
.btn-lg { padding: 15px 40px; font-size: 1.2rem; color: white; border: none; border-radius: 50px; margin: 10px; cursor: pointer; width: 80%; max-width: 300px; font-weight: bold; box-shadow: 0 4px 0 rgba(0,0,0,0.4); }
.btn-lg:active { transform: translateY(4px); box-shadow: none; }
.btn-cpu { background: var(--primary); }
.btn-online { background: var(--blue); }
input { font-size: 1.2rem; padding: 10px; margin: 10px; text-align: center; width: 60%; border-radius: 5px; border: none; }

/* ゲームコンテナ */
#game-container { flex: 1; display: flex; flex-direction: column; padding: 5px; box-sizing: border-box; width: 100%; max-width: 600px; margin: 0 auto; }
.area-header { font-size: 0.8rem; opacity: 0.9; text-align: center; margin: 2px 0; }
.card {
    width: 52px; height: 76px; background: white; color: black; border-radius: 5px;
    display: flex; justify-content: center; align-items: center; font-weight: bold; font-size: 1.2rem;
    border: 1px solid #999; box-shadow: 1px 1px 3px rgba(0,0,0,0.3);
    cursor: pointer; position: relative; z-index: 1;
}
.card.back { background: repeating-linear-gradient(45deg, #606dbc, #606dbc 10px, #465298 10px, #465298 20px); color: transparent; }
.card.selected { border: 3px solid #f1c40f; transform: translateY(-10px); box-shadow: 0 0 10px #f1c40f; z-index: 10; }
.hand-area { display: flex; gap: 4px; flex-wrap: wrap; justify-content: center; align-content: center; min-height: 90px; padding: 5px 0; }
.field-container { flex: 1; background: rgba(0,0,0,0.15); border-radius: 8px; display: flex; align-items: center; justify-content: space-between; padding: 5px; margin: 5px 0; }
.bid-col { width: 42%; display: flex; flex-direction: column; align-items: center; }
.bid-cards { display: flex; gap: 2px; flex-wrap: wrap; justify-content: center; min-height: 40px; }
.center-col { width: 16%; display: flex; flex-direction: column; align-items: center; font-size: 0.7rem; }
#status-bar { background: rgba(0,0,0,0.3); text-align: center; padding: 5px; font-size: 0.85rem; font-weight: bold; border-radius: 4px; margin-bottom: 5px; }
#log-area { height: 60px; overflow-y: auto; background: rgba(0,0,0,0.4); font-size: 0.75rem; padding: 5px; border-radius: 4px; }
.log-turn { color: #f1c40f; } .log-sys { color: #bdc3c7; }
#controls { display: flex; gap: 10px; padding: 5px; justify-content: center; }
button { flex: 1; padding: 12px; border: none; border-radius: 5px; font-size: 1rem; font-weight: bold; color: white; cursor: pointer; }
#btn-act { background: var(--primary); } #btn-fold { background: var(--danger); }
button:disabled { background: #7f8c8d; opacity: 0.5; }
#back-btn { position: absolute; top: 5px; left: 5px; padding: 5px 10px; font-size: 0.8rem; background: rgba(0,0,0,0.5); width: auto; flex: none; z-index: 50; }

/* モーダル */
#modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); display: none; flex-direction: column; justify-content: center; align-items: center; z-index: 9999; }
#modal h2 { color: #f1c40f; font-size: 2rem; margin-bottom: 20px; }
#modal p { font-size: 1.2rem; line-height: 1.6; text-align: center; margin-bottom: 30px; }
.btn-retry { background: #3498db; width: auto; padding: 10px 40px; margin: 5px; }
.btn-top { background: #7f8c8d; width: auto; padding: 10px 40px; margin: 5px; }
</style>
</head>
<body>

<div id="screen-title" class="screen">
    <h1>AUCTION</h1>
    <button class="btn-lg btn-cpu" onclick="modeSelect('CPU')">ひとりで遊ぶ</button>
    <button class="btn-lg btn-online" onclick="modeSelect('ONLINE')">友達と遊ぶ</button>
</div>

<div id="screen-lobby" class="screen hidden">
    <h2>オンライン対戦</h2>
    <p>合言葉(数字)を決めて入力してください</p>
    <input type="text" id="room-id-input" placeholder="部屋ID (例: 777)">
    <div>
        <button class="btn-lg btn-cpu" onclick="createRoom()">部屋を作る(Host)</button>
        <button class="btn-lg btn-online" onclick="joinRoom()">部屋に入る(Guest)</button>
    </div>
    <p id="lobby-msg" style="color: #f1c40f; margin-top: 20px;"></p>
    <button onclick="location.reload()" style="background:none; border:1px solid #fff; width:auto; padding:5px 20px; margin-top:20px;">戻る</button>
</div>

<div id="game-container" class="hidden">
    <button id="back-btn" onclick="location.reload()">TOP</button>
    <div>
        <div class="area-header"><span id="opp-name">CPU</span> (手札: <span id="cpu-cnt">13</span>)</div>
        <div class="hand-area" id="cpu-hand"></div>
    </div>

    <div class="field-container">
        <div class="bid-col">
            <div class="area-header"><span id="opp-label">CPU</span> 入札</div>
            <div class="bid-cards" id="cpu-bid"></div>
            <div class="area-header">計: <span id="cpu-sum">0</span></div>
        </div>
        <div class="center-col">
            <div class="area-header">出品</div>
            <div style="display:flex; flex-direction:column; gap:5px; margin: 5px 0;">
                <div id="lst-cpu" class="card back" style="width:36px; height:50px;">?</div>
                <div id="lst-plr" class="card back" style="width:36px; height:50px;">?</div>
            </div>
            <div class="area-header">山: <span id="deck-n">26</span></div>
        </div>
        <div class="bid-col">
            <div class="area-header">あなた 入札</div>
            <div class="bid-cards" id="plr-bid"></div>
            <div class="area-header">計: <span id="plr-sum">0</span></div>
        </div>
    </div>

    <div id="status-bar">準備中...</div>
    
    <div>
        <div class="area-header">あなたの手札 (タップで選択)</div>
        <div class="hand-area" id="plr-hand"></div>
    </div>

    <div id="controls">
        <button id="btn-fold" onclick="fold()">降りる</button>
        <button id="btn-act" onclick="action()">入札する</button>
    </div>
    
    <div id="log-area"></div>
</div>

<div id="modal">
    <h2>ゲーム終了</h2>
    <p id="modal-msg"></p>
    <div id="modal-btns"></div>
</div>

<script>
// ■■■ Firebase 設定 ■■■
const firebaseConfig = {
  apiKey: "AIzaSyBID6kYSN3Pp4seo0-c-GiYWQJvx80Zf7s",
  authDomain: "auction-game-b3931.firebaseapp.com",
  projectId: "auction-game-b3931",
  storageBucket: "auction-game-b3931.firebasestorage.app",
  messagingSenderId: "821044018378",
  appId: "1:821044018378:web:1cdb25f16ba4fa2da34833",
  databaseURL: "https://auction-game-b3931-default-rtdb.asia-southeast1.firebasedatabase.app"
};

let db = null;
try {
    if (typeof firebase !== 'undefined') {
        if (!firebase.apps.length) firebase.initializeApp(firebaseConfig);
        db = firebase.database();
    }
} catch(e) { console.error("Firebase Init Error", e); }

// ■■■ ゲーム変数 ■■■
let deck = [], pHand = [], cHand = [];
let pList = null, cList = null;
let pBid = [], cBid = [];
let pSelect = [];
let phase = 'SETUP';
let turn = null;
let tieCount = 0;

// モード管理
let gameMode = ''; // 'CPU' or 'ONLINE'
let myRole = 'p1'; // Online用: 'p1'(Host) or 'p2'(Guest)
let roomId = null;
let roomRef = null;

// UI要素取得
const ui = {
    cCnt: document.getElementById('cpu-cnt'),
    cHand: document.getElementById('cpu-hand'),
    cBid: document.getElementById('cpu-bid'),
    cSum: document.getElementById('cpu-sum'),
    lCpu: document.getElementById('lst-cpu'),
    lPlr: document.getElementById('lst-plr'),
    deckN: document.getElementById('deck-n'),
    pBid: document.getElementById('plr-bid'),
    pSum: document.getElementById('plr-sum'),
    pHand: document.getElementById('plr-hand'),
    status: document.getElementById('status-bar'),
    btnAct: document.getElementById('btn-act'),
    btnFold: document.getElementById('btn-fold'),
    log: document.getElementById('log-area'),
    modal: document.getElementById('modal'),
    modalMsg: document.getElementById('modal-msg'),
    modalBtns: document.getElementById('modal-btns'),
    oppName: document.getElementById('opp-name'),
    oppLabel: document.getElementById('opp-label')
};

// ■■■ 画面遷移とモード選択 ■■■
function showScreen(id) {
    document.querySelectorAll('.screen').forEach(e => e.classList.add('hidden'));
    document.getElementById('game-container').classList.add('hidden');
    if(id === 'game') document.getElementById('game-container').classList.remove('hidden');
    else document.getElementById(id).classList.remove('hidden');
}

function modeSelect(m) {
    gameMode = m;
    if (m === 'ONLINE') {
        if(!db) return alert("通信エラー: インターネットを確認してください");
        showScreen('screen-lobby');
    } else {
        myRole = 'p1';
        ui.oppName.innerText = "CPU"; ui.oppLabel.innerText = "CPU";
        showScreen('game');
        init();
    }
}

// ■■■ ゲーム初期化 (CPU/Online共通) ■■■
function init() {
    deck = [];
    for(let i=0; i<2; i++) for(let v=1; v<=13; v++) deck.push({ val: v });
    shuffle(deck);

    pHand = []; cHand = [];
    for(let v=1; v<=13; v++) {
        pHand.push({ val: v });
        cHand.push({ val: v });
    }

    ui.modal.style.display = 'none';
    ui.log.innerHTML = '';
    
    if(gameMode === 'ONLINE' && myRole === 'p1') {
        syncToFirebase();
    }
    
    startRound();
}

function resetGame() {
    init();
}

function startRound() {
    pList = null; cList = null;
    pBid = []; cBid = [];
    pSelect = [];
    tieCount = 0;
    turn = null;

    if(deck.length < 2) { endGame(); return; }

    phase = 'LISTING';
    cList = deck.pop();
    pList = deck.pop();
    
    log("--- 新しいラウンド ---", "sys");
    updateView();

    setTimeout(() => {
        phase = 'BID';
        ui.status.innerText = "入札フェーズ: カードを選んでください";
        updateView();
        if(gameMode === 'ONLINE') syncToFirebase();
    }, 800);
}

// ■■■ プレイヤーアクション ■■■
function toggleCard(index) {
    if(phase !== 'BID' && phase !== 'COMPARE') return;
    if(phase === 'COMPARE' && turn !== 'PLAYER') return;
    // Online: turn check
    if(gameMode === 'ONLINE' && phase === 'COMPARE' && turn !== myRole) return;

    const selIdx = pSelect.indexOf(index);
    if(selIdx >= 0) pSelect.splice(selIdx, 1);
    else pSelect.push(index);
    updateView();
}

function action() {
    if(pSelect.length === 0) return alert("カードを選んでください");
    
    pSelect.sort((a,b) => b - a);
    let selectedCards = [];
    pSelect.forEach(idx => {
        selectedCards.push(pHand[idx]);
        pHand.splice(idx, 1);
    });
    selectedCards.reverse();
    pSelect = [];

    const addVal = sum(selectedCards);

    if(phase === 'COMPARE') {
        const currentP = sum(pBid);
        const currentC = sum(cBid);
        if(currentP + addVal <= currentC) {
            pHand.push(...selectedCards);
            pHand.sort((a,b) => a.val - b.val);
            updateView();
            return alert(`相手の合計(${currentC})を上回る必要があります`);
        }
    }

    pBid = [...pBid, ...selectedCards];
    
    if(phase === 'BID') {
        log(`あなた: 入札 (伏せ)`, "turn");
        if(gameMode === 'CPU') {
            cpuSimultaneousBid();
            resolveSimultaneous();
        } else {
            syncToFirebase();
        }
    } else {
        log(`あなた: 追加 +${addVal} (計${sum(pBid)})`, "turn");
        if(gameMode === 'CPU') checkComparison();
        else syncToFirebase(); // Online check happens via Host sync
    }
}

function fold() {
    if(!confirm("降りますか？")) return;
    
    if(gameMode === 'CPU') {
        if(phase === 'BID') {
            const cpuAction = cpuDecideSimultaneous();
            if(cpuAction.type === 'FOLD') {
                log("両者降り。不成立。", "sys");
                discardLists();
                returnBids();
                startRound();
            } else {
                cBid = removeCards(cHand, cpuAction.cards);
                log("あなた: 降り", "turn");
                resolveWin('CPU');
            }
        } else {
            log("あなた: 降り", "turn");
            resolveWin('CPU');
        }
    } else {
        // Online Fold
        // 特殊処理: 降りたことを伝える
        let u = {};
        u[myRole + '_fold'] = true;
        if(roomRef) roomRef.update(u);
        log("あなた: 降り", "turn");
    }
}

// ■■■ CPU ロジック (復旧版) ■■■
function cpuSimultaneousBid() {
    const decision = cpuDecideSimultaneous();
    if(decision.type === 'BID') {
        cBid = [...cBid, ...removeCards(cHand, decision.cards)];
    } 
}

function cpuDecideSimultaneous() {
    const potVal = cList.val + 7;
    const budget = potVal > 20 ? 8 : (potVal > 15 ? 5 : 2);
    if(potVal < 5 && Math.random() > 0.8) return { type: 'FOLD' };

    let bestCard = -1, minDiff = 99;
    for(let i=0; i<cHand.length; i++) {
        let diff = Math.abs(cHand[i].val - budget);
        if(diff < minDiff) {
            minDiff = diff;
            bestCard = cHand[i].val;
        }
    }
    if(bestCard !== -1) return { type: 'BID', cards: [bestCard] };
    return { type: 'FOLD' };
}

function cpuTurnComparison() {
    const diff = sum(pBid) - sum(cBid);
    const potVal = cList.val + 7;

    if(sum(cBid) + diff + 1 > potVal && Math.random() > 0.3) {
        log("CPU: 降り", "sys");
        resolveWin('PLAYER');
        return;
    }

    let candidates = cHand.filter(c => c.val > diff);
    if(candidates.length === 0) {
        log("CPU: 降り(手札不足)", "sys");
        resolveWin('PLAYER');
        return;
    }

    candidates.sort((a,b) => a.val - b.val);
    const playCard = candidates[0];
    
    cBid.push(...removeCards(cHand, [playCard.val]));
    log(`CPU: 追加 +${playCard.val} (計${sum(cBid)})`, "sys");
    checkComparison();
}

function resolveSimultaneous() {
    updateView();
    if(cBid.length === 0) {
        log("CPU: 降り", "sys");
        resolveWin('PLAYER');
        return;
    }
    checkComparison();
}

function checkComparison() {
    phase = 'COMPARE';
    const ps = sum(pBid);
    const cs = sum(cBid);
    updateView();

    if(ps === cs) {
        log(`同点(${ps})。同時追加へ`, "sys");
        tieCount++;
        if(tieCount >= 3) {
            log("3回同点のため不成立", "sys");
            discardLists();
            returnBids();
            startRound();
            return;
        }
        setTimeout(() => {
            phase = 'BID'; 
            ui.status.innerText = "同点：追加カードを選んでください";
            updateView();
        }, 1000);
    } else if(ps > cs) {
        turn = 'CPU';
        ui.status.innerText = "CPU思考中...";
        updateView();
        setTimeout(cpuTurnComparison, 1000);
    } else {
        turn = 'PLAYER';
        ui.status.innerText = "相手より小さいです。追加か降りを";
        updateView();
    }
}

function resolveWin(winner) {
    phase = 'RESOLVE';
    ui.lPlr.classList.remove('back'); ui.lPlr.innerText = pList.val;
    ui.lCpu.classList.remove('back'); ui.lCpu.innerText = cList.val;
    
    log(`勝者: ${winner === 'PLAYER' ? 'あなた' : 'CPU'}`, "sys");

    setTimeout(() => {
        const pot = [pList, cList];
        if(winner === 'PLAYER') {
            pHand.push(...pot); cHand.push(...cBid);
        } else {
            cHand.push(...pot); pHand.push(...pBid);
        }
        pHand.sort((a,b) => a.val - b.val);
        cHand.sort((a,b) => a.val - b.val);
        
        startRound();
    }, 2500);
}

function discardLists() { pList = null; cList = null; }
function returnBids() {
    pHand.push(...pBid); cHand.push(...cBid);
    pHand.sort((a,b) => a.val - b.val);
    cHand.sort((a,b) => a.val - b.val);
}
function endGame() {
    phase = 'END';
    const ps = sum(pHand); const cs = sum(cHand);
    let msg = `あなた: ${ps}点<br>CPU: ${cs}点<br><br>`;
    if(ps > cs) msg += "あなたの勝利！"; else if(cs > ps) msg += "CPUの勝利..."; else msg += "引き分け";
    ui.modalMsg.innerHTML = msg;
    // CPU戦用の終了ボタン
    ui.modalBtns.innerHTML = `<button class="btn-retry" onclick="resetGame()">もう一度遊ぶ</button><button class="btn-top" onclick="location.reload()">TOPに戻る</button>`;
    ui.modal.style.display = 'flex';
}

// ■■■ オンライン機能 (State Sync) ■■■
function createRoom() {
    const id = document.getElementById('room-id-input').value;
    if(!id) return alert("部屋IDを入力してください");
    roomId = id; myRole = 'p1';
    roomRef = db.ref('rooms/' + roomId);
    document.getElementById('lobby-msg').innerText = "部屋を作成中...";
    
    // 初期データのセット
    let d = []; for(let i=0; i<2; i++) for(let v=1; v<=13; v++) d.push({ val: v }); shuffle(d);
    let h1 = []; let h2 = []; for(let v=1; v<=13; v++) { h1.push({ val: v }); h2.push({ val: v }); }
    
    roomRef.set({
        created: Date.now(),
        deck: d,
        phase: 'SETUP',
        turn: null,
        p1_hand: h1, p1_bid: [], p1_list: null, p1_fold: false,
        p2_hand: h2, p2_bid: [], p2_list: null, p2_fold: false,
        msg: "待機中... ID: " + id
    }).then(() => {
        ui.oppName.innerText = "Guest"; ui.oppLabel.innerText = "Guest";
        showScreen('game');
        roomRef.off();
        roomRef.on('value', onSync);
        setTimeout(hostStartRound, 1000);
    });
}

function joinRoom() {
    const id = document.getElementById('room-id-input').value;
    if(!id) return alert("部屋IDを入力してください");
    roomId = id; myRole = 'p2';
    roomRef = db.ref('rooms/' + roomId);
    document.getElementById('lobby-msg').innerText = "接続中...";
    
    roomRef.get().then(snap => {
        if(!snap.exists()) {
            document.getElementById('lobby-msg').innerText = "";
            return alert("部屋が見つかりません");
        }
        ui.oppName.innerText = "Host"; ui.oppLabel.innerText = "Host";
        showScreen('game');
        roomRef.off();
        roomRef.on('value', onSync);
    });
}

function syncToFirebase() {
    if(!roomRef) return;
    const updates = {};
    if(myRole === 'p1') {
        updates['deck'] = deck;
        updates['p1_hand'] = pHand; updates['p1_bid'] = pBid; updates['p1_list'] = pList;
        if(phase === 'RESOLVE' || phase === 'LISTING' || phase === 'SETUP') {
             updates['p2_hand'] = cHand; updates['p2_bid'] = cBid; updates['p2_list'] = cList;
        }
        updates['phase'] = phase;
        updates['turn'] = turn;
    } else {
        updates['p2_hand'] = pHand; updates['p2_bid'] = pBid;
    }
    roomRef.update(updates);
}

function onSync(snapshot) {
    const val = snapshot.val();
    if(!val) return;
    
    deck = val.deck || [];
    phase = val.phase;
    turn = val.turn;
    
    if (myRole === 'p1') {
        pHand = val.p1_hand || []; pBid = val.p1_bid || []; pList = val.p1_list;
        cHand = val.p2_hand || []; cBid = val.p2_bid || []; cList = val.p2_list;
        hostGameLoop(val);
    } else {
        pHand = val.p2_hand || []; pBid = val.p2_bid || []; pList = val.p2_list;
        cHand = val.p1_hand || []; cBid = val.p1_bid || []; cList = val.p1_list;
    }
    
    if(val.msg && ui.status.innerText !== val.msg) {
        log(val.msg, "sys");
        ui.status.innerText = val.msg;
    }

    // オンライン用終了画面
    if(phase === 'END') showOnlineEndGame();
    else ui.modal.style.display = 'none';

    updateView();
}

// Host Logic
function hostStartRound() {
    if(deck.length < 2) { roomRef.update({ phase: 'END', msg: "ゲーム終了" }); return; }
    let nd = [...deck];
    let l1 = nd.pop(); let l2 = nd.pop();
    roomRef.update({
        deck: nd, phase: 'LISTING',
        p1_list: l1, p2_list: l2,
        p1_bid: [], p2_bid: [],
        p1_fold: false, p2_fold: false,
        msg: "新しいラウンド"
    });
    setTimeout(() => { roomRef.update({ phase: 'BID', msg: "入札してください" }); }, 1000);
}

function hostGameLoop(val) {
    // Check BID phase completion
    if(phase === 'BID') {
        // Check if both bids are present or someone folded (fold flagged in Sync)
        // Simplified check: if both bids have cards (or were updated).
        // Using a better check: check if both sides have bid > 0 or fold flag.
        // However, for simplicity in this merged version, we trigger if local state shows both bids.
        if(pBid.length > 0 && cBid.length > 0) {
             // Need to debounce or use a 'done' flag in a real app, but here we rely on status change.
             // To avoid loop, only act if phase is BID in DB.
             resolveSimultaneousOnline();
        }
    } else if(phase === 'COMPARE') {
        checkComparisonOnline(); 
    }
    if(val.p1_fold && phase !== 'RESOLVE') resolveWinOnline('p2');
    else if(val.p2_fold && phase !== 'RESOLVE') resolveWinOnline('p1');
}

function resolveSimultaneousOnline() {
    checkComparisonOnline();
}
function checkComparisonOnline() {
    const s1 = sum(pBid); const s2 = sum(cBid);
    let nextPhase = 'COMPARE'; let nextTurn = null; let nextMsg = "";
    if(s1 === s2) { nextPhase = 'BID'; nextMsg = `同点(${s1})。追加してください。`; }
    else if(s1 > s2) { nextTurn = 'p2'; nextMsg = "Guestのターン"; }
    else { nextTurn = 'p1'; nextMsg = "Hostのターン"; }
    if (phase !== nextPhase || turn !== nextTurn) {
         roomRef.update({ phase: nextPhase, turn: nextTurn, msg: nextMsg });
    }
}
function resolveWinOnline(winnerRole) {
    const w = (winnerRole === myRole) ? 'あなた' : '相手';
    roomRef.update({ phase: 'RESOLVE', msg: `勝者: ${w}` });
    const pot = [pList, cList];
    let n1 = [...pHand]; let n2 = [...cHand];
    if(winnerRole === 'p1') { n1.push(...pot); n2.push(...cBid); }
    else { n2.push(...pot); n1.push(...pBid); }
    n1.sort((a,b)=>a.val-b.val); n2.sort((a,b)=>a.val-b.val);
    setTimeout(() => {
        roomRef.update({ p1_hand: n1, p2_hand: n2, p1_bid: [], p2_bid: [], p1_list: null, p2_list: null, p1_fold: false, p2_fold: false }).then(() => { hostStartRound(); });
    }, 2500);
}

function showOnlineEndGame() {
    const ps = sum(pHand); const cs = sum(cHand);
    let msg = `あなた: ${ps}点<br>相手: ${cs}点<br><br>`;
    if(ps > cs) msg += "あなたの勝利！"; else if(cs > ps) msg += "相手の勝利..."; else msg += "引き分け";
    ui.modalMsg.innerHTML = msg;
    // Online用ボタン
    let btns = `<button class="btn-retry" id="btn-rematch" onclick="rematchOnline()">再戦 (Host)</button><button class="btn-top" onclick="location.reload()">TOPに戻る</button>`;
    ui.modalBtns.innerHTML = btns;
    if(myRole !== 'p1') {
        const b = document.getElementById('btn-rematch');
        b.innerText = "ホスト待ち..."; b.disabled = true; b.style.opacity = 0.6;
    }
    ui.modal.style.display = 'flex';
}
function rematchOnline() { if(myRole === 'p1') resetOnlineRoomData(roomId); }

// ■ ヘルパー
function shuffle(arr) { for(let i=arr.length-1; i>0; i--) { const j=Math.floor(Math.random()*(i+1)); [arr[i], arr[j]] = [arr[j], arr[i]]; } }
function sum(cards) { return (cards||[]).reduce((a,c) => a + c.val, 0); }
function removeCards(hand, vals) {
    let ret = [];
    vals.forEach(v => { const i = hand.findIndex(c => c.val === v); if(i !== -1) { ret.push(hand[i]); hand.splice(i, 1); } });
    return ret;
}
function log(msg, type) {
    const d = document.createElement('div'); d.className = type === 'turn' ? 'log-turn' : 'log-sys'; d.innerText = msg;
    ui.log.prepend(d);
}

// ■ 画面更新
function updateView() {
    ui.deckN.innerText = deck.length;
    ui.cCnt.innerText = cHand.length;
    
    // CPU手札
    ui.cHand.innerHTML = '';
    cHand.forEach(() => {
        const d = document.createElement('div');
        d.className = 'card back';
        d.style.width = '25px'; d.style.height = '38px';
        ui.cHand.appendChild(d);
    });

    // プレイヤー手札
    ui.pHand.innerHTML = '';
    pHand.forEach((c, i) => {
        const d = document.createElement('div');
        d.className = 'card' + (pSelect.includes(i) ? ' selected' : '');
        d.innerText = c.val;
        d.onclick = () => toggleCard(i);
        ui.pHand.appendChild(d);
    });

    // 入札
    renderCards(ui.pBid, pBid, false);
    ui.pSum.innerText = sum(pBid);
    
    // 相手入札: BID中は隠す。ただしオンラインの場合は同期ズレ防止のため表示制御に注意。
    // ここではシンプルに「BIDフェーズかつ、まだ比較に入っていない」なら隠す。
    // 自分が未入札の時だけ隠す？ -> ルール上は「同時公開」なので、全員が出すまで隠す。
    // CPU戦: BIDフェーズ中はPlayerが出した後すぐ開く(resolveSimultaneousで更新されるため)。
    // Online戦: 両者出るまでHostがBIDフェーズを維持するので隠れる。
    
    // ★CPU戦のカードオープン修正箇所
    // CPU戦では resolveSimultaneous が呼ばれた直後に updateView される。
    // その時 phase はまだ BID (checkComparison 前) かもしれないが、checkComparison内で COMPARE になる。
    // checkComparisonの最後で updateView されるので、COMPARE になっていれば表示される。
    // 唯一、同点(BIDに戻る)の場合は隠れるが、これはルール通り(再入札)。
    const hideCpu = (phase === 'BID' && pBid.length === 0); 
    // ↑ pBid.length===0 (自分がまだ出してない) なら隠す。出したら(Action押したら) 見えても良い? 
    // いや、同時公開だから Action押した瞬間は見えてよい。
    
    renderCards(ui.cBid, cBid, (phase === 'BID')); // ★シンプルにBID中は隠す設定に戻します（確実な動作のため）
    ui.cSum.innerText = (phase === 'BID') ? '?' : sum(cBid);

    // 出品
    if(pList) { ui.lPlr.innerText = pList.val; ui.lPlr.classList.remove('back'); } else ui.lPlr.innerText = '';

    if(cList) {
        if(phase === 'RESOLVE' || phase === 'END') {
            ui.lCpu.innerText = cList.val;
            ui.lCpu.classList.remove('back');
        } else {
            ui.lCpu.innerText = '?';
            ui.lCpu.classList.add('back');
        }
    } else ui.lCpu.innerText = '';

    // ボタン
    const isMyTurn = (phase === 'BID') || (phase === 'COMPARE' && turn === (gameMode==='ONLINE'?myRole:'PLAYER'));
    ui.btnAct.disabled = !isMyTurn;
    ui.btnFold.disabled = !isMyTurn;
    ui.btnAct.innerText = phase === 'BID' ? '入札' : '追加';
    ui.status.style.background = isMyTurn ? 'rgba(243, 156, 18, 0.4)' : 'rgba(0,0,0,0.3)';
}

function renderCards(el, cards, hidden) {
    el.innerHTML = '';
    cards.forEach(c => {
        const d = document.createElement('div');
        d.className = 'card ' + (hidden ? 'back' : '');
        d.innerText = hidden ? '?' : c.val;
        d.style.width = '36px'; 
        d.style.height = '50px'; 
        d.style.fontSize = '1rem';
        el.appendChild(d);
    });
}

// 開始
init(); // 初期ロード時はダミー実行(タイトル画面用)

</script>
</body>
</html>
